# CIGAR PLATFORM - ARCHITECTURE GUIDE

> **For**: Claude Code AI Assistant
> **Stack**: NestJS + Angular 20 + Prisma + Supabase + NX Monorepo
> **Last Updated**: 2025-12-27

---

## 1. FRONTEND ARCHITECTURE (Angular + Signals)

### 1.1 The "ALL STARS â­" Pattern

The frontend uses a reactive state management layer based on Angular Signals, inspired by TanStack Query. All asynchronous state flows through `injectQuery` (read/cache) and `injectMutation` (write/invalidation).

### 1.2 The Golden Rule: Reactive Getters

To respect Angular's Injection Context (avoid NG0203 error) while maintaining reactivity, **Store functions MUST accept getter functions**, not raw values.

#### âœ… CORRECT - Store Pattern

```typescript
// club.store.ts
export function injectClubStore() {
  const service = inject(ClubsService);

  return {
    // Accept getter function for reactive parameters
    getClubById: (idGetter: () => string) => injectQuery(() => ({
      queryKey: ['clubs', 'detail', idGetter()],
      queryFn: () => service.clubControllerFindOne(idGetter()),
      enabled: !!idGetter(), // Synchronous safety check
      staleTime: 5 * 60 * 1000,
    })),
  };
}
```

#### âœ… CORRECT - Component Pattern

```typescript
export class ClubProfilePage {
  #route = inject(ActivatedRoute);
  #clubStore = injectClubStore();

  // 1. Route param as Signal
  readonly clubId = toSignal(
    this.#route.paramMap.pipe(map(p => p.get('id') ?? '')),
    { initialValue: '' }
  );

  // 2. Call store getter with getter function
  readonly clubQuery = this.#clubStore.getClubById(() => this.clubId());

  // 3. Extract signals for template
  readonly club = computed(() => this.clubQuery.data());
  readonly loading = this.clubQuery.loading;
  readonly error = this.clubQuery.error;
}
```

#### âŒ WRONG - Don't Call Store from Computed

```typescript
// âŒ NEVER DO THIS - Causes NG0203 error
readonly clubQuery = computed(() => {
  const id = this.clubId();
  return id ? this.#clubStore.getClubById(id) : null; // âŒ inject() outside injection context
});
```

### 1.3 Query Implementation Details

**Key Behavior**:
- `injectQuery` creates the cache store **immediately** (synchronous initialization)
- Internal `effect()` watches for queryKey changes and switches cache stores
- Automatic reference counting for cleanup

**Enabled Option**:
```typescript
injectQuery(() => ({
  queryKey: ['users', 'current'],
  queryFn: () => api.getCurrentUser(),
  enabled: false, // Can be boolean OR Signal<boolean>
}));
```

**Static Queries** (no dynamic parameters):
```typescript
// Even static queries use factory function
const publicClubs = injectQuery(() => ({
  queryKey: ['clubs', 'public'],
  queryFn: () => service.findAll(),
  staleTime: 5 * 60 * 1000,
}));
```

### 1.4 Separation of Concerns (SOC)

| Layer | Responsibilities | Forbidden |
|-------|------------------|-----------|
| **Store** | API calls, cache management, invalidation logic, data transformation | âŒ Toasts, navigation, console.log |
| **Component** | Trigger actions, UX feedback (toasts), navigation, display | âŒ Direct API calls, complex business logic |
| **Service** | HTTP calls (generated by Orval) | âŒ State management |

**Example - Mutation in Store**:
```typescript
// In Store (club.store.ts)
const joinClub = injectMutation({
  mutationFn: ({ clubId, data }) => service.clubControllerJoinClub(clubId, data),
  onSuccess: () => {
    // Store handles cache invalidation
    queryCache.invalidateQueriesMatching(['clubs']);
  },
  // âŒ NO toasts, NO navigation here
});
```

**Example - Component Handles UX**:
```typescript
// In Component
async onJoinClub() {
  await this.#clubStore.joinClub.mutate({ clubId: '123', data: {} });

  // Component handles UX
  if (this.#clubStore.joinClub.error()) {
    this.#toastService.error('Failed to join club');
    return;
  }

  this.#toastService.success('Successfully joined!');
  this.#router.navigate(['/']);
}
```

### 1.5 Optimistic Updates

All critical mutations should implement optimistic updates for smooth UX:

```typescript
const updateProfile = injectMutation({
  mutationFn: (data) => api.updateProfile(data),

  onMutate: (variables) => {
    const prev = currentUser.data();

    // Immediate optimistic update
    if (prev) {
      currentUser.setData({ ...prev, ...variables });
    }

    // Return context for rollback
    return { prev };
  },

  onSuccess: (result) => {
    // Confirm with server data
    currentUser.setDataFresh(result);
  },

  onError: (_error, _variables, context) => {
    // Rollback on error
    if (context?.prev) {
      currentUser.setData(context.prev);
    }
  },
});
```

### 1.6 UI Components & Design System

**Priority**: Always check if a component exists in `@cigar-platform/shared/ui` before creating a new one.

**When to Create a Shared Component**:
1. Code is duplicated 2+ times
2. Visual complexity justifies isolation (e.g., `MemberCard`)
3. Component is purely presentational (inputs, buttons, display)

**Icons**: Use Lucide Icons exclusively
```typescript
import { User, Settings, LogOut } from 'lucide-angular';

@Component({
  imports: [LucideAngularModule],
  template: `<lucide-icon [img]="User" />`
})
```

**Control Flow**: Use modern Angular syntax ONLY
```typescript
// âœ… CORRECT
@if (loading()) {
  <app-spinner />
} @else if (error()) {
  <app-error [error]="error()" />
} @else {
  <app-content [data]="data()" />
}

@for (item of items(); track item.id) {
  <app-item [item]="item" />
}

// âŒ NEVER use *ngIf, *ngFor, *ngSwitch
```

### 1.7 TypeScript Strict Conventions

**Critical Rules**:
1. âœ… **Type all signals explicitly**: `readonly user: Signal<UserDto | null>`
2. âœ… **Never use `any`** - Use DTOs from `@cigar-platform/types` or `@cigar-platform/prisma-client`
3. âœ… **Never use `!` (non-null assertion)** - Use `computed()` with fallbacks
4. âœ… **Always use `?.` and `??` for null safety**
5. âŒ **Zero `console.log`** - Use query `.error()` signals

**Example**:
```typescript
// âœ… CORRECT
readonly members = computed(() => this.membersQuery.data() ?? []);
readonly memberCount = computed(() => this.members().length);

// âŒ WRONG
readonly members = this.membersQuery.data()!; // âŒ Non-null assertion
readonly memberCount = this.members().length; // âŒ Will crash if null
```

### 1.8 Security & Session Management

#### Conditional Fetching (Permissions)

Never assume a user has permissions on a sub-resource (e.g., join requests, admin settings).

**Rule**: Always pass a permission getter (`canManage: () => boolean`) to sensitive queries.

**Pattern**:
```typescript
// In Store
getJoinRequests: (clubIdGetter: () => string, canManageGetter?: () => boolean) =>
  injectQuery(() => ({
    queryKey: ['clubs', 'join-requests', clubIdGetter()],
    queryFn: () => service.getJoinRequests(clubIdGetter()),
    // Only fetch if user has permission
    enabled: !!clubIdGetter() && (canManageGetter ? canManageGetter() : true),
    staleTime: 1 * 60 * 1000,
  })),

// In Component
readonly joinRequestsQuery = this.#clubStore.getJoinRequests(
  () => this.clubId(),
  () => this.contextStore.canManageClub()
);
```

**Why**: Prevents 403 errors by not making unauthorized API calls in the first place.

#### Session Lifecycle (Logout)

The `QueryCacheService` survives logout because it's provided in `root`.

**Action**: On logout, call `queryCache.clear()`.

**Expected Behavior**:
- Cache MUST clear data (`setData(null)`)
- Cache MUST invalidate entries
- Cache MUST NOT delete keys from the map to avoid "Store not found" errors on components still active during cleanup

**Implementation**:
```typescript
// auth.service.ts
signOut(): Observable<void> {
  return from(this.#supabaseService.client.auth.signOut()).pipe(
    tap(() => {
      this.#currentUserSignal.set(null);
      this.#sessionSignal.set(null);

      // Clear cache without deleting stores
      this.#queryCache.clear();
    }),
    switchMap(() => from(this.#router.navigate(['/auth/login']))),
  );
}

// query-cache.service.ts
clear(): void {
  for (const [, entry] of this.#cache.entries()) {
    entry.instance.setData(null); // Clear data
    entry.instance.invalidate();  // Mark as stale
    // âŒ DON'T: this.#cache.delete(key)
  }
}
```

#### HTTP Interceptors

- 401/403 errors are intercepted globally
- A 403 error on a Query with `enabled` is a sign of bad frontend logic (the query should not have been launched)
- If you see 403 on a conditional query, the permission check in `enabled` is wrong

---

## 2. BACKEND ARCHITECTURE (NestJS + Prisma)

### 2.1 The Single Source of Truth: Prisma

**Prisma** defines all data models. Any schema change MUST be followed by a Prisma migration:

```bash
npx prisma migrate dev --name descriptive_name
```

### 2.2 The Data Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Prisma Schema â†’ NestJS DTOs â†’ Swagger â†’ Orval â†’ Angular   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Step-by-Step Flow**:
1. **Modify** `schema.prisma`
2. **Run** `npx prisma migrate dev`
3. **Create/Update** NestJS DTOs with `class-validator` decorators
4. **Add** `@ApiProperty` decorators for Swagger
5. **Generate** Angular services: `npm run generate:api`
6. **Update** Angular Store to use new types

### 2.3 NestJS Controllers & DTOs

**Controllers** must expose complete Swagger documentation:

```typescript
@ApiTags('clubs') // Orval groups by tag
@Controller('clubs')
export class ClubsController {
  @Get(':id')
  @ApiOperation({ summary: 'Get club by ID' })
  @ApiResponse({ type: ClubResponseDto })
  async findOne(@Param('id') id: string): Promise<ClubResponseDto> {
    // Never return raw Prisma objects
    return this.service.findOne(id);
  }
}
```

**DTOs** must use class-validator:

```typescript
import { IsEmail, IsString, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateClubDto {
  @IsString()
  @MinLength(3)
  @ApiProperty({ example: 'My Cigar Club' })
  name: string;

  @IsEmail()
  @ApiProperty({ example: 'admin@club.com' })
  email: string;
}
```

### 2.4 Response Format

**Lists** must always return pagination metadata:

```typescript
interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
  };
}
```

**All responses** are wrapped by `TransformInterceptor`:

```typescript
// API returns
return { id: '123', name: 'Club' };

// Client receives
{
  "success": true,
  "data": { "id": "123", "name": "Club" }
}
```

### 2.5 Supabase Integration

**Authentication**:
- Supabase manages auth (JWT tokens)
- NestJS validates JWT via `JwtAuthGuard`
- **Auto-sync**: Users are automatically created in Prisma on first API access

```typescript
// jwt-auth.guard.ts
async canActivate(context: ExecutionContext): Promise<boolean> {
  const supabaseUser = await this.supabaseService.verifyToken(token);

  // Auto-create user in Prisma if doesn't exist
  let dbUser = await this.prisma.user.findUnique({
    where: { id: supabaseUser.id },
  });

  if (!dbUser) {
    dbUser = await this.prisma.user.create({
      data: {
        id: supabaseUser.id,
        email: supabaseUser.email!,
        displayName: supabaseUser.user_metadata?.full_name ?? 'User',
      },
    });
  }

  request.user = { ...supabaseUser, dbUser };
  return true;
}
```

**Storage**: Use Supabase Storage for files (avatars, covers)

### 2.6 Error Handling

Use **custom exceptions** with error codes:

```typescript
// Throw typed exceptions
throw new UserNotFoundException(userId);
throw new InvalidTokenException();

// Global filter transforms to:
{
  "success": false,
  "error": {
    "code": "AUTH_USER_NOT_FOUND",
    "message": "User not found",
    "statusCode": 404
  }
}
```

### 2.7 Security Checklist

- âœ… **Never return raw Prisma objects** - Use ResponseDTOs
- âœ… **Validate all inputs** with `ValidationPipe`
- âœ… **Verify ownership** before modifications (use `OwnerGuard`)
- âœ… **Never expose sensitive data** (passwords, tokens)

---

## 3. CODE QUALITY & STANDARDS

### 3.1 Git Commit Format

```
<type>: <emoji> <description> --duration=XX
```

**Rules**:
- **English** descriptions only
- **Max ~80 characters**
- **No** "Co-Authored-By" or "Generated with Claude Code"

**Types & Emojis**:
| Type | Emoji | Usage |
|------|-------|-------|
| `feat` | ğŸš€ | New feature |
| `fix` | ğŸ”§ | Bug fix |
| `refactor` | â™»ï¸ | Refactoring (no functional change) |
| `chore` | ğŸ“¦ | Maintenance, dependencies |
| `test` | ğŸ§ª | Add/modify tests |
| `docs` | ğŸ“ | Documentation |

**Example**:
```bash
feat: ğŸš€ implement reactive getter pattern for queries --duration=45
fix: ğŸ”§ resolve synchronous store initialization issue --duration=20
```

### 3.2 Pre-Commit Checklist

Before committing:
- [ ] All parameters/returns are typed
- [ ] No `any` usage
- [ ] No `!` non-null assertions
- [ ] No `console.log`
- [ ] Code builds successfully: `npm run build:all`
- [ ] Commit message follows format

### 3.3 Common Commands

| Task | Command |
|------|---------|
| Dev - API | `npm run api:serve` |
| Dev - Web | `npm run web:serve` |
| Build All | `npm run build:all` |
| Generate API Client | `npm run generate:api` |
| Prisma Studio | `npm run prisma:studio` |
| Prisma Migrate | `npm run prisma:migrate` |

---

## 4. REAL-WORLD EXAMPLES

### 4.1 Complete Feature Implementation

**Task**: Add "favorite clubs" feature

**1. Backend (NestJS)**:
```typescript
// 1. Update schema.prisma
model UserFavoriteClub {
  id        String   @id @default(cuid())
  userId    String
  clubId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  club Club @relation(fields: [clubId], references: [id])

  @@unique([userId, clubId])
}

// 2. Run migration
// npx prisma migrate dev --name add_favorite_clubs

// 3. Create DTO
export class AddFavoriteDto {
  @IsString()
  @ApiProperty()
  clubId: string;
}

// 4. Create Controller
@Post('favorites')
@ApiOperation({ summary: 'Add club to favorites' })
async addFavorite(@Body() dto: AddFavoriteDto): Promise<void> {
  return this.service.addFavorite(dto);
}

// 5. Generate API client
// npm run generate:api
```

**2. Frontend (Angular)**:
```typescript
// 1. Store (user.store.ts)
export function injectUserStore() {
  const service = inject(UsersService);
  const queryCache = inject(QueryCacheService);

  return {
    // Query for favorites list
    favoriteClubs: injectQuery(() => ({
      queryKey: ['user', 'favorites'],
      queryFn: () => service.usersControllerGetFavorites(),
      staleTime: 2 * 60 * 1000,
    })),

    // Mutation to add favorite
    addFavorite: injectMutation({
      mutationFn: (clubId: string) =>
        service.usersControllerAddFavorite({ clubId }),
      onSuccess: () => {
        // Invalidate favorites list
        queryCache.invalidateQueriesMatching(['user', 'favorites']);
      },
    }),
  };
}

// 2. Component
@Component({...})
export class FavoritesPage {
  #userStore = injectUserStore();

  readonly favorites = computed(() =>
    this.#userStore.favoriteClubs.data() ?? []
  );
  readonly loading = this.#userStore.favoriteClubs.loading;

  async onAddFavorite(clubId: string) {
    await this.#userStore.addFavorite.mutate(clubId);

    if (this.#userStore.addFavorite.error()) {
      this.#toastService.error('Failed to add favorite');
      return;
    }

    this.#toastService.success('Added to favorites!');
  }
}
```

---

## 5. TROUBLESHOOTING

### NG0203: Injection Context Error

**Cause**: Calling `inject()` outside injection context (field initializer, constructor)

**Solution**: Use reactive getter pattern
```typescript
// âŒ WRONG
readonly query = computed(() => this.store.getData(this.id()));

// âœ… CORRECT
readonly query = this.store.getData(() => this.id());
```

### Query Not Initialized Error

**Cause**: Calling `setDataFresh()` before store is created (old bug, now fixed)

**Solution**: Ensure `injectQuery` initializes store synchronously (already implemented)

### Stale Data After Mutation

**Cause**: Missing cache invalidation

**Solution**: Always invalidate related queries
```typescript
onSuccess: () => {
  queryCache.invalidateQueriesMatching(['clubs']); // Invalidates all club queries
}
```

---

## 6. KEY REMINDERS

1. **Stores accept getters**: `(idGetter: () => string)`
2. **Components pass getters**: `this.store.getData(() => this.id())`
3. **Never call `inject()` in `computed()` or `effect()`**
4. **Always invalidate cache after mutations**
5. **Use `computed()` with fallbacks**: `data() ?? []`
6. **Zero `console.log`, zero `!`, zero `any`**
7. **Run `npm run generate:api` after backend changes**
8. **Follow git commit format strictly**

---

**Why "ALL STARS â­"?**

This architecture ensures:
- âœ… Type safety from database to UI
- âœ… Automatic cache invalidation
- âœ… Zero manual subscriptions
- âœ… Optimistic updates for smooth UX
- âœ… Compiler errors if API changes
- âœ… Self-documenting code via Swagger

Follow these patterns strictly for all new features.
